<!DOCTYPE html>
<html>
<head>
 <nav>
    <div class="nav-wrapper">
      <a href="#" class="brand-logo">> Welcome!</a>
      <UL id="nav-mobile" class="right hide-on-med-and-down">
		<LI><a href="methodologiesQuiz.html">Quiz</a></LI>
        <LI><a href="#top">Waterfall Model</a></LI>
        <LI><a href="#middle">RAD</a></LI>
        <LI><a href="#bottom">Agile Methods</a></LI>
      </UL>
    </div>
  </nav>
 <title> Methodologies </title>
  <!-- Compiled and minified CSS -->
 <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.8/css/materialize.min.css">
  
 <!-- Compiled and minified JavaScript -->
 <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.8/js/materialize.min.js"></script>
 
  <!-- Tab Logo Image -->
 <link rel="icon" href="http://materialdesignblog.com/wp-content/uploads/2015/01/motion.png">

</head>
<body>
<div id="page-wrap">

<script>
</script>

<style>

 @-webkit-keyframes slide
 {
  0%   {background-position: 0 0;}
  100% {background-position: 10000px 0;}
 }

 .card-title {
  font-size: 40px !important;
 }

 .card {
  margin-top: 30px;
 }

 #text {
  margin-bottom: 20px;
 }
 
 #page-wrap {
  width: 800px;
  margin: 0 auto;
 }
 
 .nav-wrapper {
  background-color:#00827F;
 }
 
</style>

<h1 style="font-family:courier;"> METHODOLOGIES </h1>
<p> In this page, we will be exploring the fundamentals of Methodologies and how it is used in various ways. These will include three different types of Methodologies including their structure and how it is applicable
 to different types businesses. </p>
<p><b> Types of Methodologies: </b></p>	
<OL>
<LI><b> Waterfall Life cycle/model </b></LI>
<LI><b> Rapid Application Development (RAD) </b> - E.g. Spiral Model </LI>
<LI><b> Agile Methods </b> - E.g. Extreme Programming </LI>
</OL>
 
<div id="top"><a href="top"></a></div>
<h3 style="font-family:courier;"> WATERFALL LIFE CYCLE/MODEL </h3>
<p><b>CONTEXT: </b> The Waterfall Life cycle was originally established by Dr Winston W. Royce and was written during 1970 - Royce had critiqued that his model still had flaws and that is was still applicable to software development 
to certain extents.</p>

<p>Regardless, the Waterfall Life cycle is still commonly used in modern software development today, a common example would be almost any gaming company in which most of their games involve testing at a consumer based level
which may include alpha/beta testing stages in two variations; open or closed. Testing is essential in modern software development as it helps to debug and maintain the software to an acceptable standard towards consumers
for when it is officially released or sold.</p>

<p>The model is sequential/linear meaning that each stage has to be finished in order to proceed to the next stage in an ordinally fashion. This is where Royce had made a necessary change to allow a return to previous stages if 
certain problems had occured in the current stage due to a previous mistake or problem in a former stage; hence the name given to the model as it is displayed as a Waterfall with arrows descending and ascending throughout
multiple stages.</p>

<div class="card row">
<div class="card-content">
<center>
<img id="Waterfall_model" src="https://i.imgur.com/z53S66d.jpg" alt="watermodel" width="600" height="400">
</center>
</div>
</div>

<div class="card row">
<div class="card-content">
<p>The stages of the Waterfall Lifecycle (following Royce's original phrases):</p>
<OL>
<LI><b> Requirements </b> - System and Software requirements including documentation.</LI>
<LI><b> Analysis </b> - Considerations of feasibility during development (i.e. technical, economical, legal, operations, schedule).</LI>
<LI><b> Design </b> - A design method is implemented to structure parts of the software (e.g. data dictionary, data flow diagrams, flow charts, structure diagrams). </LI>
<LI><b> Coding </b> - Looks at development aspects including integration of other codes and testing individual units.</LI>
<LI><b> Testing </b> - Includes elements of testing (i.e. alpha/best testing & white/black box).</LI>
<LI><b> Maintenance </b> - Focuses on updating the software (after released or before), such as corrective, perfective or adaptive maintenance (usually continuous).</LI>
</OL>
</div>
</div>

<div class="card row">
<div class="card-content">
<p><b>Why it might be used:</b></p>
<OL>
<LI>Used in linear projects where requirements are specified and fixated at the beginning.</LI>
<LI>No real benefit towards the customer of having it early - arguably less time consumable.</LI>
<LI>Often used for short projects (e.g. videogames, softwares, products etc.)</LI>
<LI>Used as a method of trial and error to establish an ideal image.LI>
<LI>Model is extremely easy to implement and output.</OL>
</OL>
</div>
</div>

<div class="card row">
<div class="card-content">
    <table class="striped">
        <thead>
          <tr>
              <th data-field="pros">Pros</th>
              <th data-field="cons">Cons</th>
			    </tr>
        </thead>

        <tbody>
          <tr>
            <td>Documentation allows analysis and crucial building points to expand</td>
            <td>Lots of documentation can also mean it will be time consuming</td>
          </tr>
		  <tr>
			<td>Easy to schedule and arrange tasks to judge processes</td>
			<td>Requirements may have to be modified if system fails to meet criteria</td>
		  </tr>
		  <tr>
			<td>Testers not needed during early development</td>
			<td>Testers not involved until late stage could affect late crucial feedback</td>
		  </tr>
		  <tr>
			<td>Coding is structured and laid out so it is easy to organise</td>
			<td>Efficient coding is not prioritised</td>
		  </tr>
		</tbody>
	</table>
</div>
</div>


<div id="middle"><a href="middle"></a></div>
<h3 style="font-family:courier;"> RAPID APPLICATION DEVELOPMENT (RAD)</h3>
<p><b>CONTEXT: </b> Rapid Application Development was originally introduced by James Martin and was established in 1981. It is said to be an alternative towards the Waterfall Life cycle as its primary focus is on the process
for the software development as opposed to the planning involved (i.e. less documentation involved).</p>

<p>RAD can be explained in steps few steps which can be iterated to produce a refined final prototype which becomes the final product. Usually an analysis and a quick design is used to begin the prototype which is then further
modified/alternated through multiple stages (some could be repeated several times) which often involves refining, developing and demonstrating the product the client.</p>

<div class="card row">
<div class="card-content">
<center>
<img id="RAD_model" src="https://i.imgur.com/AkyQHry.jpg" alt="radmodel" width="600" height="400">
</center>
</div>
</div>

<div class="card row">
<div class="card-content">
<p>The stages of the RAD Model (using a typical modern example):</p>
<OL>
<LI><b> Requirements </b> - Necessary details of the prototype are noted including System and Software requirements.</LI>
<LI><b> Demonstrate </b> - Evaluating the prototype with client.</LI>
<LI><b> Develop </b> Producing the prototype from the requirements and feedback from demonstration.</LI>
<LI><b> Refine </b> - Modifying or upgrading the prototype accordingly from feedback.</LI> 
<LI><b> Testing </b> - Testing the functions of the prototype.</LI>
<LI><b> Deployment </b> - Final product of the prototype (end product).</LI>
</OL>
</div>
</div>

<div class="card row">
<div class="card-content">
<p><b>Why it might be used:</b></p>
<OL>
<LI>When client/customer is uncertain of their requirements.</LI>
<LI>RAD is often used when a system can be modularised (i.e. flexibility or variation required).</LI>
<LI>Certain stages/cycles are made easier to managed.</LI>
<LI>Used as a method of trial and error to establish an ideal image.</LI>
</OL>
</div>
</div>

<div class="card row">
<div class="card-content">
    <table class="striped">
        <thead>
          <tr>
              <th data-field="pros">Pros</th>
              <th data-field="cons">Cons</th>
			    </tr>
        </thead>

        <tbody>
          <tr>
            <td>Helpful when requirements become obscure</td>
            <td>Efficient code is not often prioritised</td>
          </tr>
		  <tr>
			<td>Usually results in excellent usability</td>
			<td>Can be straining on client's time for feedback</td>
		  </tr>
		  <tr>
			<td>Encourages customer feedback</td>
			<td>Programmer's have to constantly adhere to client's need</td>
		  </tr>
		  <tr>
			<td>Alternating requirements can be accomodated</td>
		  </tr>
		</tbody>
	</table>
</div>
</div>
		  

<h3 style="font-family:courier;"> THE SPIRAL MODEL </h3>
<p><b>CONTEXT: </b> An example of RAD would be the Spiral Model which was invented by Barry w. Boehm during 1988. The spiral model adds the RAD prototyping and multiple risk analysis stages (to allow further analysis) to the already established
waterfall model we've encountered before, the entire cycle consists of four divided quadrants (sections) and is shape as a spiral, hence its name. The starting point of the model lies in the center of the spiral which is then 
slowly proceeded by following each quadrant clock-wise until the end is reached.</p>

<p>Likewise, the spiral model is similar to the waterfall model as it builds upon the baseline of multiple software development models. These include the requirements, development, design, coding and testing. With the exception that the
sprial model places a high priority on risk analysis - this is further reinforced through stages of iteration as the developing project would repeatedly pass through each quadrant until it reaches the end of the spiral.<p>

<div class="card row">
<div class="card-content">
<center>
<img id="Spiral_model" src="https://i.imgur.com/GjZsmOr.png" alt="spiralmodel" width="600" height="400">
</center>
</div>
</div>

<div class="card row">
<div class="card-content">
<p>As such, each quadrant/phase can be given its appropriate name starting with:</p>
<OL>
<LI><b>Quadrant 1 </b> - Objectives/Alternatives</LI>
<LI><b>Quadrant 2 </b> - Evaluating/Risk Analysis</LI>
<LI><b>Quadrant 3 </b> - Developing/Designing</LI>
<LI><b>Quadrant 4 </b> - Planning</LI>
</OL>
<p>Remember that in order to proceed to the next quadrant, you have to travel clock-wise throughout the spiral, so that the starting point lies on quadrant 1 ("Review") and that the end point ends at quadrant 3 
("Service").</p>
</div>
</div>

<div class="card row">
<div class="card-content">
<p><b>Why it might be used:</b></p>
<OL>
<LI>High chances of risks involved for a project.</LI>
<LI>Users/client unsure of wanted product.</LI>
<LI>Varying changes expected overtime (market and research).</LI>
<LI>Long-term project that is fixated from the start.</LI>
<LI>Explore different aspects of products (so new products are introduced).</LI>
</OL>
</div>
</div>

<div class="card row">
<div class="card-content">
    <table class="striped">
        <thead>
          <tr>
              <th data-field="pros">Pros</th>
              <th data-field="cons">Cons</th>
			    </tr>
        </thead>

        <tbody>
          <tr>
            <td>Lots of risk analysis so there is a high chance of avoiding risk</td>
            <td>Risk analysis often require specific high skillsets to detect</td>
          </tr>
		  <tr>
			<td>Strong project control (including documentation)</td>
			<td>Success of project solely depends on risk analysis stage</td>
		  </tr>
		  <tr>
			<td>Ideal model for large group projects as it breaks down large stages which is then risk analysed</td>
			<td>Not ideal for small group projects as it is too time consuming for each stage</td>
		  </tr>
		  <tr>
			<td>Software is usually introduced early into the Spiral Model</td>
			<td>Can be relatively expensive as it involves more expertised skillsets</td>
		  </tr>
		</tbody>
	</table>
</div>
</div>


<div id="bottom"><a href="bottom"></a></div>
<h3 style="font-family:courier;"> AGILE METHODS </h3>
<p><b>CONTEXT: </b> Agile Methods, similar to the Waterfall Life cycle, was once again created from Dr. Winston W. Royce except in an indirect manner, where a community of software engineers had taken Royce's criticism in the
sequential/linear development cycle to create a more effective and light method - allowing a change in direction of a project throughout its development cycle. A specific reason for this design  was by the time a project had 
successfully been completed using this method, the project becomes irrelevant and outdated due to all the time needed to reach every requirement. This is especially important as in the world of business markets and products are 
constantly changing at a fast pace and that companies cannot be completely dependent on one project as a liability.</p>

<p><b>The 12 principles (guidelines) of Agile Methodology:</b></p>
<OL>
<LI>Customer satisfaction by early and continuous delivery of valuable software</LI>
<LI>Welcome changing requirements, even in late development</LI>
<LI>Working software is delivered frequently (weeks rather than months)</LI>
<LI>Close, daily cooperation between business people and developers</LI>
<LI>Projects are built around motivated individuals, who should be trusted</LI>
<LI>Face-to-face conversation is the best form of communication (co-location)</LI>
<LI>Working software is the principal measure of progress</LI>
<LI>Sustainable development, able to maintain a constant pace</LI>
<LI>Continuous attention to technical excellence and good design</LI>
<LI>Simplicity—the art of maximizing the amount of work not done—is essential</LI>
<LI>Best architectures, requirements, and designs emerge from self-organizing teams</LI>
<LI>Regularly, the team reflects on how to become more effective, and adjusts accordingly</LI>
</OL>
<a href="https://en.wikipedia.org/wiki/Agile_software_development#Agile_principles"><i>Source (Wikipedia) - Agile Principles</i></a>

<p>Since there are many variations and generlisations of Agile Methods, there is no official diagram able to completely justify each stage by one diagram/model. As such, this could be operationalised by thinking back to the 
Waterfall Life cycle but with each stage not having to become linear/sequential and that any stage could hop onto the next since it isn't fixated.</p>

<p>Here's a quick mock-up I produced (may not be entirely representable):</p>
<div class="card row">
<div class="card-content">
<center>
<img id="Agile_model" src="https://i.imgur.com/ipEVVr4.jpg" alt="agilemodel" width="600" height="400">
</center>
</div>
</div>

<div class="card row">
<div class="card-content">
<p><b>Why it might be used:</b></p>
<OL>
<LI>Provides opportunities to assess the direction of the project.</LI>
<LI>Potentially shippable product available as resource.</LI>
<LI>Greatly reduce development costs and time to market.</LI>
<LI>Helps companies build the right product as it is never irrelevant.</LI>
<LI>Multiple opportunities to improve different aspects of the project.</LI>
</OL>
</div>
</div>

<div class="card row">
<div class="card-content">
    <table class="striped">
        <thead>
          <tr>
              <th data-field="pros">Pros</th>
              <th data-field="cons">Cons</th>
			    </tr>
        </thead>

        <tbody>
          <tr>
            <td>Regular maintenance of every work aspect</td>
            <td>Could eventually become time consuming</td>
          </tr>
		  <tr>
			<td>Able to steer project in another direction</td>
			<td>Time wasted on previous work produced</td>
		  </tr>
		  <tr>
			<td>Encourages groups of teams to colloborate together</td>
			<td>Higher employment costs and management of teams</td>
		  </tr>
		  <tr>
			<td>Able to make the right product for the company</td>
			<td>Working on a long project could potentially be draining</td>
		  </tr>
		</tbody>
	</table>
</div>
</div>

<h3 style="font-family:courier;"> EXTREME PROGRAMMING (XP) </h3>
<p><b>CONTEXT: </b> Extreme programming is an example agile methods, unfortunately the title isn't what it entirely suggests. Instead it involves pair programming (where two developers program together) which promotes the use of a flat management 
structure (there is only one manager controlling each and every pair group) in order to produce quality software production and potentially increases the productivity of working on long projects. Since extreme programming uses a 
flat management structure, it is highly encouraged to work in a small team of developers as management should be kept simple and coherent, otherwise it would be hard to manage each individual groups of pairs amongst a 
large team of developers.</p>

<p>Working in pairs allow developers to take shifts in programming and testing amongst the software so there is a continuous flow of feedback and opportunities for improvement with every working shift. As a result, it is 
arguably less tiresome and more motivating when working in pairs as there is an alternation of the work needing to be produced which is less tiring when the workload is shared. However, pair programming usually involves
being at one workstation together as a pair and therefore requires two programmers to be in the same geographic location, otherwise it wouldn't necessarily work as efficiently or work at all.

<div class="card row">
<div class="card-content">
<center>
<img id="Agile_model" src="https://i.imgur.com/OYFUq2F.png" alt="agilemodel" width="600" height="400">
</center>
<a href="https://en.wikipedia.org/wiki/Extreme_programming#/media/File:Extreme_Programming.svg"><i>Image Source (Wikipedia) - XP Model</i></a>
</div>
</div>

<div class="card row">
<div class="card-content">
<p>The stages of Extreme Programming:<p>
<OL>
<LI><b>Release Plan </b> - Current planning of the intended project/software</LI>
<LI><b>Iteration Plan </b> - Steps/stages to be repeated as a quality assurance check</LI>
<LI><b>Acceptance Test </b> - Software is then tested for acceptability (required standard)</LI>
<LI><b>Stand up Meeting </b> - Developers/programmers meet together to further discuss any other requirements or plans</LI>
<LI><b>Pair Negotiation </b> - Assigned pairs will discuss with each other on what tasks they will be handling</LI>
<LI><b>Unit Test </b> - Modules of the source code is broken down and tested individually to make sure procedures work as intended</LI>
<LI><b>Pair Programming </b> - Each pair will produced a module of the software which will then be merged for the complete product</LI>
<LI><b>Code </b> - The final code is assembled with all the modules produced which is then the final product/software</LI>
</div>
</div>

<div class="card row">
<div class="card-content">
<p><b>Why it might be used:</b></p>
<OL>
<LI>Provides opportunities to assess the direction of the project.</LI>
<LI>Potentially shippable product available as resource.</LI>
<LI>Greatly reduce development costs and time to market.</LI>
<LI>Helps companies build the right product as it is never irrelevant.</LI>
<LI>Multiple opportunities to improve different aspects of the project.</LI>
</OL>
</div>
</div>

<div class="card row">
<div class="card-content">
    <table class="striped">
        <thead>
          <tr>
              <th data-field="pros">Pros</th>
              <th data-field="cons">Cons</th>
			    </tr>
        </thead>

        <tbody>
          <tr>
            <td>Continuous flow of feedback</td>
            <td>Feedback may not always be useful</td>
          </tr>
		  <tr>
			<td>Less draining when working on long-term projects</td>
			<td>Working in pairs usually means long-shifts</td>
		  </tr>
		  <tr>
			<td>Able to work together in one workstation</td>
			<td>Pair has to be in the same geographic location</td>
		  </tr>
		  <tr>
			<td>Increase productivity amongst the work force</td>
			<td>Only able to work in small groups for it to be effective</td>
		  </tr>
		</tbody>
	</table>
</div>
</div>
</div>
</body>
</html>